%[a b c].pop
%w[a b c].pop
a=%w[a b c].pop
(a=%w[a b c]).pop
(a=%w[a b c]).shift
a
Rack::Utils::SYMBOL_TO_STATUS_CODE[:forbidden]
{}.respond_to?
{}.respond_to?(:[])
{:status => :forbidden}.delete[:status]
{:status => :forbidden}.delete(:status)
{}.(:status)
{}.delete(:status)
%[{"date":"Mon Jun 03 2013 10:26:04 GMT-0700 (PDT)","process":{"pid":97730,"uid":502,"gid":20,"cwd":"/Users/Reid/Work/ATT-Cloud/silvertip","execPath":"/usr/local/bin/node","version":"v0.10.9","argv":["/usr/local/bin/node","/Users/Reid/Work/ATT-Cloud/silvertip/server"],"memoryUsage":{"rss":31535104,"heapTotal":28055552,"heapUsed":10926432}},"os":{"loadavg":[0.310546875,0.4609375,0.5546875],"uptime":257038},"trace":[{"column":15,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js","function":"Object.exports.middleware","line":6,"method":"exports.middleware","native":false},{"column":25,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"Function.port","line":44,"method":"port","native":false},{"column":61,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js","function":"Function.app.configure","line":393,"method":"app.configure","native":false},{"column":9,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"","line":31,"method":null,"native":false},{"column":26,"file":"module.js","function":"Module._compile","line":456,"method":"_compile","native":false},{"column":10,"file":"module.js","function":"Object.Module._extensions..js","line":474,"method":"Module._extensions..js","native":false},{"column":32,"file":"module.js","function":"Module.load","line":356,"method":"load","native":false},{"column":12,"file":"module.js","function":"Function.Module._load","line":312,"method":"Module._load","native":false},{"column":10,"file":"module.js","function":"Function.Module.runMain","line":497,"method":"Module.runMain","native":false},{"column":16,"file":"node.js","function":"startup","line":119,"method":null,"native":false}],"stack":["Error: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","    at Object.exports.middleware (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js:6:15)","    at Function.port (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:44:25)","    at Function.app.configure (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js:393:61)","    at Object.<anonymous> (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:31:9)","    at Module._compile (module.js:456:26)","    at Object.Module._extensions..js (module.js:474:10)","    at Module.load (module.js:356:32)","    at Function.Module._load (module.js:312:12)","    at Function.Module.runMain (module.js:497:10)","    at startup (node.js:119:16)"],"level":"error","message":"uncaughtException: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","timestamp":"2013-06-03T17:26:04.851Z"}]
e=%[{"date":"Mon Jun 03 2013 10:26:04 GMT-0700 (PDT)","process":{"pid":97730,"uid":502,"gid":20,"cwd":"/Users/Reid/Work/ATT-Cloud/silvertip","execPath":"/usr/local/bin/node","version":"v0.10.9","argv":["/usr/local/bin/node","/Users/Reid/Work/ATT-Cloud/silvertip/server"],"memoryUsage":{"rss":31535104,"heapTotal":28055552,"heapUsed":10926432}},"os":{"loadavg":[0.310546875,0.4609375,0.5546875],"uptime":257038},"trace":[{"column":15,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js","function":"Object.exports.middleware","line":6,"method":"exports.middleware","native":false},{"column":25,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"Function.port","line":44,"method":"port","native":false},{"column":61,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js","function":"Function.app.configure","line":393,"method":"app.configure","native":false},{"column":9,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"","line":31,"method":null,"native":false},{"column":26,"file":"module.js","function":"Module._compile","line":456,"method":"_compile","native":false},{"column":10,"file":"module.js","function":"Object.Module._extensions..js","line":474,"method":"Module._extensions..js","native":false},{"column":32,"file":"module.js","function":"Module.load","line":356,"method":"load","native":false},{"column":12,"file":"module.js","function":"Function.Module._load","line":312,"method":"Module._load","native":false},{"column":10,"file":"module.js","function":"Function.Module.runMain","line":497,"method":"Module.runMain","native":false},{"column":16,"file":"node.js","function":"startup","line":119,"method":null,"native":false}],"stack":["Error: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","    at Object.exports.middleware (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js:6:15)","    at Function.port (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:44:25)","    at Function.app.configure (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js:393:61)","    at Object.<anonymous> (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:31:9)","    at Module._compile (module.js:456:26)","    at Object.Module._extensions..js (module.js:474:10)","    at Module.load (module.js:356:32)","    at Function.Module._load (module.js:312:12)","    at Function.Module.runMain (module.js:497:10)","    at startup (node.js:119:16)"],"level":"error","message":"uncaughtException: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","timestamp":"2013-06-03T17:26:04.851Z"}]
p=JSON.parse(e)
p.process
p['process']
p['trace']
z=Zone.first
vm = Vms.first
vm = Vm.first
vm.flavor
ssh cosmic
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.match /token/g
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/g
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/i
keys = (params={'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}).keys.grep /token/i
keys.detect { |k|params[k]}
keys.select { |k|params[k]}
keys.find { |k|params[k]}
keys.map({ |k|params[k]})
keys.map({ |k| params[k] })
keys.map { |k| params[k] }
keys.map { |k| params[k] }.first
me=User.first
me.synaptic_user_id
me.synaptic_user_id='999'
me.save
Project
IRB.conf[:HISTORY_PATH]
puts HISTFILE
    @reject_data = [
"http://portal.local/contacts/edit".gsub(/"#{'http://portal.local'}"/, '')
site='http://portal.local'
"http://portal.local/contacts/edit".gsub(/#{site}/, '')
"https://portal.local/contacts/edit".gsub(/#{site}/, '')
"http://portal.local:3001/contacts/edit".gsub(/#{site}/, '')
site
site += ':3000'
"http://portal.local:3000/contacts/edit".gsub(/#{site}/, '')
site.gsub!(/:3000$/, '')
site.include?(':')
Contact.orphaned
[:foo].tap { |a| a << :bar if :bar }
[:foo].tap { |a| a << :bar if false }
[:foo].tap { |a| a.shift :bar if true }
[:foo].tap { |a| a.shift(:bar) if true }
[:foo].tap { |a| a.unshift(:bar) if true }
u=User.first
u.project_admin? nil
u1=User.find_by_email("reidmix@gmail.com")
u.project_admin nil
u.admin?
u1.project_admin? nil
  def webphone_url email_or_attuid
    return email_or_attuid if email_or_attuid !~ ATT_UID_REGEX
    "http://webphone.att.com/cgi-bin/webphones.pl?id=#{attuid}"
  end
webphone_url rx278x
webphone_url 'rx278x'
  ATT_UID_REGEX = /^([a-zA-Z]{2}[0-9]{3}[a-zA-Z0-9]{1})(?:@att.com)?/
    "http://webphone.att.com/cgi-bin/webphones.pl?id=#{$1}"
webphone_url 'rx278x@att.com'
webphone_url 'rx278x@att.net'
webphone_url 'rx278x@comcast.com'
  def webphone_url attuid
    return attuid if attuid !~ ATT_UID_REGEX
webphone_url 'rx278f@comcast.com'
  ATT_UID_REGEX = /^([a-zA-Z]{2}[0-9]{3}[a-zA-Z0-9]{1})(?:@att.com)?$/
link_to webphone_url 'rx278x@att.net'
link_to webphone_url('rx278x@att.net')
include UrlHelpers
include ActionView::Helpers::UrlHelpers
include ActionView::Helpers::UrlHelper
include ActionView::Helpers
include ActionDispatch::Routing
include Rails.application.routes.url_helpers
ActionDispatch::Routing
ActionView::Helpers::UrlHelper
link_to 'http://google.com'
default_url_options[:host] = "localhost"
url_for()
class LinkHelper; include ActionView::Helpers; end
helper = LinkHelper.new
helper.link_to 'http://google.com'
helper.mail_to 'http://google.com'
helper.link_to 'rf278x'
helper.link_to 'rf278x@att.com'
helper.link_to 'Google', 'rf278x@att.com'
'foo' =~ ATT_UID_REGEX
'rx278x' =~ ATT_UID_REGEX
'rx278x' =~ ATT_UID_REGEX && 'yes'
'rx278x' =~ ATT_UID_REGEX && 'yes' || 'no'
'rx278' =~ ATT_UID_REGEX && 'yes' || 'no'
{}.reverse_merge(target: 'default')
(h={}).reverse_merge(target: 'default')
h
(h={target: 'foo'}).reverse_merge(target: 'default')
nil =~ ATT_UID_REGEX
Identity.first
Identity.first.user
Identity.find_by_user_id(1)
i=Identity.find_by_user_id(1)
Identity.find_by_openstack_identifier('a7322faf05d44038a4398a060880ab8b')
Contact
SLP.const_get('caportal-prod-a-dfw2', false)
SLP.const_get('Ewr1', false)
+1
z.tenants
z.tenants.first.project
u.serialized_attributes
User.serialized_attributes
me.versions
ls
me
me.role='admin'
me.class.serialized_attributes
me.versions.first
old=me.versions.first.reify
me.changes
me.role='developer'
me.serialized_attributes
me.changed_attributes
me.version.changes
me.version.changeset
me.versions.changeset
me.previous_version.changeset
me.versions.first.changeset
me.reload
me.role = 'developer'
me.role
me.version.first.changeset
me.previous_version
me.versions.last
me.versions.last.reify
me.attributes
me.attributes.grep /pass/
me.attributes.keys.grep /pass/
p=Project.first
p.zone
p.tenant.zone
p.tenants
p.tenants.map(&:zone)
p.tenants.map(&:zone).map(&:name)
Zone
p.tenants.map(&:zone).map(&:code)
p.tenants.distinct.map(&:zone).map(&:code)
p.tenants(distinct: true)
p.tenants.zones(distinct: true)
p
p.zones
p.zones.map(&:code)
p.zones.length
Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1))
Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1)).to_sql
puts Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1)).to_sql
puts Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1))
puts Project.where(:id => Tenant.select(:project_id).join(:credentials).where(:user_id => user)).to_sql
puts Project.where(:id => Tenant.select(:project_id).join(:credentials).where(:user_id => 1)).to_sql
Project.accessible_to(User.first).to_sql
puts Project.accessible_to(User.first).to_sql
puts Project.accessible_to2(User.first).to_sql
puts Project.accessible_to2(1).to_sql
Project.memberships_project_ids_for(1)
Project.memberships_project_ids_for(1).to_sql
puts Project.memberships_project_ids_for(1).to_sql
puts Project.credentials_project_ids_for(1).to_sql
Project.accessible_to2(1).to_sql
Project.memberships_project_ids_for(user).where_values
Project.memberships_project_ids_for(1).where_values
Project.memberships_project_ids_for(1).where_values.to_sql
Project.memberships_project_ids_for(1).where_values.reduce(:and)to_sql
Project.memberships_project_ids_for(1).where_values.reduce(:and)
puts Project.accessible_to(1).to_sql
puts Project.accessible_to(1)
Project.accessible_to(1)
Project.accessible_to(1).map(&:name)
Project.accessible_to(2).map(&:name)
Project.accessible_to(3).map(&:name)
reload!@
EmailValidator
EmailValidator::EmailAddressRegex
include 'benchmark'
require 'benchmark'
Benchmark.bm { 1000.times do { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.bm { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.realtime { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.realtime { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } 
Benchmark.bm { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } 
Benchmark.bm { x.report("times:") { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } }
Benchmark.bm { |x| x.report("times:") { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } }
Benchmark.realtime { 1000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } / 1000
Benchmark.realtime { 10000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } / 10000
Benchmark.realtime { 100000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 1000000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 750000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 600000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 700000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Project.accessible_to.to_sql
Project.accessible_to(1).to_sql
Project.membership_projects_for(1).union(Project.credential_projects_for(1)).to_sql
reload1
reload
AppConfig
AppConfig.ssh_connections
class Foo; def foo; puts "foo #{wibble}"; end; end
Bar.new.wibble
Foo.new.foo 
class Foo; initialize(bar); @context = bar; end; end
class Foo; def initialize(bar); @context = bar; end; end
f=Foo.new
f=Foo.new(Bar.new)
class Foo; def run method; @context.send method; end; end
f.run(:wibble)
f.foo
class Foo; def foo; puts "foo #{self.wibble}"; end; end
Foo.new.foo
Bar.new.instance_eval { Foo.new.foo } 
undef Foo
class Foo; initialize; end; end
class Foo; initialize; ;  end; end
Foo.new
class Bar; def wibble; 123; end; end
Bar.new.instance_exec { Foo.new.foo }
c=HostImporter::HostConfig
c=HostImporter::HostConfig.new
c.field :test
c.field :test, :test
c.field :test => :test
c.field :test { puts 'yes' }
c.field :test do; puts 'yes'; end
be bundle open activerecord
'server_name'.titleize
[nil].compact.flatten
[:to_i].compact.flatten
[[:to_i, :devide_by_ten]].compact.flatten
'os'.titlelize
'os'.titleize
'o-s'.titleize
'c16r2'.split 'r', 2
  IDENTIFIER_REGEX = /([cso])(\d+)([rp])(\d+)/
'x16r2' =~ IDENTIFIER_REGEX
  IDENTIFIER_REGEX = /([a-z])(\d+)([rp])([a-z])/
  def node
    identifier =~ IDENTIFIER_REGEX
    {
      :type   => $1,
      :number => $2,
      :rack   => {
        :prefix => $3,
        :row    => $4
      }
    }
identifier = 'c16r2'
node[:type]
def identifier
'c16r2'
node[:number]
  IDENTIFIER_REGEX = /([a-z])(\d+)([rp])(\d+)/
 NODE_TYPES = {
    :c => 'compute',
    :s => 'storage',
    :o => 'ops'
  }.with_indifferent_access
  # set a default value & freeze
  NODE_TYPES.default = 'unknown'
  NODE_TYPES.freeze
NODE_TYPES[node[:type]]
def identifier; 'x12r23'; end
node[:rack][:prefix]
node[:rack][:row]
def identifier; 'aaaaaaaa'; end
node
'c12r23'.split 'r', 2
x = 'c12r23'.split 'r', 2
x.first
x.first[1..-1]
''.hostname '.'
''.split '.'
class Foo; attr_accessible :config; end
class Foo; attr_accessor :config; end
Foo.setup
Foo.new.config
class Foo; def config; self.class.config; end; end
Foo.config
Foo.methods - 1.methods
Foo.new.setup
class Foo; def setup; self.class.setup; end; end
class Bar; class_attribute :config; end
class Bar; class << self; def setup; @config = 'yay'; end; end
;end
Bar.setup
Bar.new.config
class Bar; class << self; def setup; config = 'yay'; end; end; end
class A
class_attribute :x
A.x = 'yay'
A.new.x
class Bar; class << self; def setup; self.config = 'yay'; end; end; end
zone = Zone.find_by_code('dfw1')
zone = Zone.find_by_code('dfw2')
zone.server_racks
sr=zone.server_racks.first_or_create! :rack_identifier => 23, :node_type => 'compute'
sr.node_type
quit
class Foo; def import(s); s.tap {|s| before_import(s) }.each {|d| puts d }; end; end;
end;
class Foo; def import(s); s.tap {|s| before_import(s) }.each {|d| puts d }; end; end
class Bar < Foo
before_import {|s| puts s.length; s.reject! {|d| d.include?('x') } }
class Foo
def import s
  s.tap do |s| 
    preprocess && preprocess.call(s)
  end.each do |d|
    puts d
attr_accessor :preprocess
class << self
  def import stream
    stream.tap do |s|
      preprocess && preprocess.call(s)
    end.each do |d|
      puts d
  attr_accessor :preprocess
  def before_import &block
    preprocess = &block
  class << self
    attr_acccessor :callback
    def import stream
      stream.tap do |s|
        callback.call(s) if callback
      end.each do |data|
        puts data
      end
    def before_import &block
      callback = block
  before_import do |s|
    puts "BEFORE: #{s.length}"
    s.reject! { |d| d.include?('x') }
    puts " AFTER: #{s.length}"
    attr_accessor :callback
Bar.new.import %w[a b c d e f]
Bar.import %w[a b c d e f]
Bar.import %w[a b c d e f x]
        puts callback
        puts "CALLBACK? #{callback.inspect}"
      self.callback = block
c=Contacts.first
c=Contact.first
n=Contact.new
n.first_name = 'Reid"
'
n.first_name = 'Reid'
n.last_name = 'MacDonald'
n.email = c.email.upcase
n.valid?
n.errors.messages
{:foo=>'bar}.each_value(&:upcase)
"
{:foo=>'bar'}.each_value(&:upcase)
{:foo=>'bar'}.each_value!(&:upcase)
(h={:foo=>'bar'}).each_value(&:upcase)
(h={:foo=>'bar'}).each_value { |v| puts v.upcase }
(h={:foo=>'bar'}).each_value { |v| v.upcase! }
{:foo=>'bar'}.each_value!(&:upcase!)
{:foo=>'bar'}.each_value(&:upcase!)
i=(h={:foo=>'bar'}).dup.each_value!(&:upcase!)
i=(h={:foo=>'bar'}).dup.each_value(&:upcase!)
i
i=(h={:foo=>'bar'}).clone.each_value(&:upcase!)
i=(h={:foo=>'bar'}).map.each_value(&:upcase!)
Contacts.first
Contact.first
Contact.find_by_email c.email.upcase
Contact.find_by_email c.email
n
n = Contact.new
n.first_name='Reid'
n.last_name='MacDonald'
Contact.find_by_email 'REIDMIX@gmail.com'
class Foo; attr_accessor :host; end
f.host = 'foo'
f.instance_variable_get(:host)
Foo.new do 
f=Foo.new do |foo|
foo.host = 'reid'
f
f.host
Foo.new do |o| 
puts o.inspect
Foo.new { |o| puts 'test' }
class Foo; def bar(s='bar'); yield s; end 
Foo.bar
Foo.new.bar
Foo.new.bar {|s| puts s; 'baz'}
s=Foo.new.bar {|s| puts s; 'baz'}
s
[].push 'a'
{:a => 'b', :c => 'd'}.reverse_merge(:a=>'z')
{:a => 'b', :c => 'd'}.merge(:a=>'z')
{:a => 'z'}.reverse_merge(:a=>'b', :c => 'd')
Module Bax
module Bar
def hostname
  'default
module Bar; def hostname; 'default'; end; end
class Baz
include Bar
def hostname; 'override'; end
Baz.new.hostname
hi=HostImporter.new Zone.first, {:hostname => 'c16r12.attcompute.com'}
hi.hostname
hi.class.configure
hi.class.configure {}
hi.config
hi.config = HostConfig.new
hi
h=Host.new
host.name
hi.config.hostname
hi = HostImporter.new Zonf.first
hi.identifier
hi.valid_identifier
hi.valid_identifier?
hi.node[:id]
hi.node[:type]
hi.node[:rack][:prefix]
hi.node[:rack][:id]
hi.find_host
hi.send(:find_host)
h=hi.send(:find_host)
h.id
h.new_record?
hi.config.finder
zone
hi.zone
hi.send(hi.config.parent)
hi.send(hi.config.parent).send(hi.config.record)
hi.send(hi.config.parent).send(hi.config.record).send(config.finder)
hi.send(hi.config.parent).send(hi.config.record).send(hi.config.finder)
hi.send(hi.config.parent).send(hi.config.record).send(hi.config.finder).where(:identifier => 'c12r13')
zone.hosts.where(:identifier => 'c7r7').find
Zone.first.hosts.where(:identifier => 'c7r7').find
Zone.first.hosts.first_or_create.where(:identifier => 'c7r7')
Zone.first.hosts.first_or_create(:identifier => 'c7r7')
Zone.first.hosts
Zone.first.hosts.send(:find_or_create, :identifier => 'c12r13')
Zone.first.hosts.send(:first_or_create, :identifier => 'c12r13')
Zone.first.hosts.first_or_create(:identifier => 'c12r13')
Zone.first.hosts.where(config.lookup => identifier).first_or_create
Zone.first.hosts.where(hi.config.lookup => identifier).first_or_create
Zone.first.hosts.where(hi.config.lookup => hi.identifier).first_or_create
hi=HostImporter.new(Zone.first, {:hostname => 'c16r12.attcompute.com'})
hi.send :find_host
Zone.first.hosts.where(:identifier => 'c16r12').first
Zone.first.hosts.where(:identifier => 'c16r12').last
Zone.first.hosts.where(:identifier => 'c16r12').find
Zone.first.hosts.where(:identifier => 'c16r12').all
IRB.conf
      {:hostname => 'c10r16.keep.com',   :reject => false },
      {:hostname => 'c11r16.reject.com', :reject => true  },
      {:hostname => 'c12r16.keep.com',   :reject => false }
    ]
data = @reject_data
      def data; data; end
    Class.new do
end
mock.new.data
mock =     Class.new do
      def stream; data; end
      def host; self; end
      def save; true; end
    end
mock.new.stream
HostConfig
HostConfig::Identifier
HostImporter::Identifier
git stash
c=SLP::Ewr1::Compute.new Zone.find_by_code('erw1')

results = []
results = results[1..-1] unless results.empty?
results
c
c.get_sql_results ''
c.map_rows [[]]
c.map_rows [[1, 'me@reid.com'],[]], :id, :email
c.map_rows [1, 'me@reid.com'], :id, :email
c.map_rows [], :id, :email
c.map_rows [[]], :id, :email
a.first.compact
a.first
a.first[:email]
a=c.map_rows [[]], :id, :email
a.first.delete_if! {|_,v| v.blank? }
a.first.delete_if! {|_,v| v.nil? }
a.first.delete_if {|_,v| v.nil? }
a={:name => nil}
a={}{
}
a={}
a.empty?
a=c.map_rows []
c.text_to_array_of_arrays nil, "\t"
reload!
c=zone.broker.compute
c=zone.brokers.compute
c=zone.broker
zone = Zone.find_by_code('ewr1')
zone = Zone.find_by_code('erw1')
 Zone.all.map(&:code)
zone = Zone.new(:code => 'ewr1')
zone.broker
zone.broker.compute
c = SLP::Ewr1::Compute.new Zone.first
c.map_rows []
%[a b c].pop
%w[a b c].pop
a=%w[a b c].pop
(a=%w[a b c]).pop
(a=%w[a b c]).shift
a
Rack::Utils::SYMBOL_TO_STATUS_CODE[:forbidden]
{}.respond_to?
{}.respond_to?(:[])
{:status => :forbidden}.delete[:status]
{:status => :forbidden}.delete(:status)
{}.(:status)
{}.delete(:status)
%[{"date":"Mon Jun 03 2013 10:26:04 GMT-0700 (PDT)","process":{"pid":97730,"uid":502,"gid":20,"cwd":"/Users/Reid/Work/ATT-Cloud/silvertip","execPath":"/usr/local/bin/node","version":"v0.10.9","argv":["/usr/local/bin/node","/Users/Reid/Work/ATT-Cloud/silvertip/server"],"memoryUsage":{"rss":31535104,"heapTotal":28055552,"heapUsed":10926432}},"os":{"loadavg":[0.310546875,0.4609375,0.5546875],"uptime":257038},"trace":[{"column":15,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js","function":"Object.exports.middleware","line":6,"method":"exports.middleware","native":false},{"column":25,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"Function.port","line":44,"method":"port","native":false},{"column":61,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js","function":"Function.app.configure","line":393,"method":"app.configure","native":false},{"column":9,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"","line":31,"method":null,"native":false},{"column":26,"file":"module.js","function":"Module._compile","line":456,"method":"_compile","native":false},{"column":10,"file":"module.js","function":"Object.Module._extensions..js","line":474,"method":"Module._extensions..js","native":false},{"column":32,"file":"module.js","function":"Module.load","line":356,"method":"load","native":false},{"column":12,"file":"module.js","function":"Function.Module._load","line":312,"method":"Module._load","native":false},{"column":10,"file":"module.js","function":"Function.Module.runMain","line":497,"method":"Module.runMain","native":false},{"column":16,"file":"node.js","function":"startup","line":119,"method":null,"native":false}],"stack":["Error: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","    at Object.exports.middleware (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js:6:15)","    at Function.port (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:44:25)","    at Function.app.configure (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js:393:61)","    at Object.<anonymous> (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:31:9)","    at Module._compile (module.js:456:26)","    at Object.Module._extensions..js (module.js:474:10)","    at Module.load (module.js:356:32)","    at Function.Module._load (module.js:312:12)","    at Function.Module.runMain (module.js:497:10)","    at startup (node.js:119:16)"],"level":"error","message":"uncaughtException: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","timestamp":"2013-06-03T17:26:04.851Z"}]
e=%[{"date":"Mon Jun 03 2013 10:26:04 GMT-0700 (PDT)","process":{"pid":97730,"uid":502,"gid":20,"cwd":"/Users/Reid/Work/ATT-Cloud/silvertip","execPath":"/usr/local/bin/node","version":"v0.10.9","argv":["/usr/local/bin/node","/Users/Reid/Work/ATT-Cloud/silvertip/server"],"memoryUsage":{"rss":31535104,"heapTotal":28055552,"heapUsed":10926432}},"os":{"loadavg":[0.310546875,0.4609375,0.5546875],"uptime":257038},"trace":[{"column":15,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js","function":"Object.exports.middleware","line":6,"method":"exports.middleware","native":false},{"column":25,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"Function.port","line":44,"method":"port","native":false},{"column":61,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js","function":"Function.app.configure","line":393,"method":"app.configure","native":false},{"column":9,"file":"/Users/Reid/Work/ATT-Cloud/silvertip/server.js","function":"","line":31,"method":null,"native":false},{"column":26,"file":"module.js","function":"Module._compile","line":456,"method":"_compile","native":false},{"column":10,"file":"module.js","function":"Object.Module._extensions..js","line":474,"method":"Module._extensions..js","native":false},{"column":32,"file":"module.js","function":"Module.load","line":356,"method":"load","native":false},{"column":12,"file":"module.js","function":"Function.Module._load","line":312,"method":"Module._load","native":false},{"column":10,"file":"module.js","function":"Function.Module.runMain","line":497,"method":"Module.runMain","native":false},{"column":16,"file":"node.js","function":"startup","line":119,"method":null,"native":false}],"stack":["Error: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","    at Object.exports.middleware (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/att-express-auth/index.js:6:15)","    at Function.port (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:44:25)","    at Function.app.configure (/Users/Reid/Work/ATT-Cloud/silvertip/node_modules/express/lib/application.js:393:61)","    at Object.<anonymous> (/Users/Reid/Work/ATT-Cloud/silvertip/server.js:31:9)","    at Module._compile (module.js:456:26)","    at Object.Module._extensions..js (module.js:474:10)","    at Module.load (module.js:356:32)","    at Function.Module._load (module.js:312:12)","    at Function.Module.runMain (module.js:497:10)","    at startup (node.js:119:16)"],"level":"error","message":"uncaughtException: You have to pass the app, clientId and clientSecret, a default redirect and a list of scopes. For example:","timestamp":"2013-06-03T17:26:04.851Z"}]
p=JSON.parse(e)
p.process
p['process']
p['trace']
z=Zone.first
vm = Vms.first
vm = Vm.first
vm.flavor
ssh cosmic
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.match /token/g
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/g
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/
{'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}.keys.grep /token/i
keys = (params={'token' => 'lc', 'TOKEN' => 'uc', 'Token' => 'cc', 'ToKeN' => 'mc'}).keys.grep /token/i
keys.detect { |k|params[k]}
keys.select { |k|params[k]}
keys.find { |k|params[k]}
keys.map({ |k|params[k]})
keys.map({ |k| params[k] })
keys.map { |k| params[k] }
keys.map { |k| params[k] }.first
me=User.first
me.synaptic_user_id
me.synaptic_user_id='999'
me.save
Project
IRB.conf[:HISTORY_PATH]
puts HISTFILE
    @reject_data = [
"http://portal.local/contacts/edit".gsub(/"#{'http://portal.local'}"/, '')
site='http://portal.local'
"http://portal.local/contacts/edit".gsub(/#{site}/, '')
"https://portal.local/contacts/edit".gsub(/#{site}/, '')
"http://portal.local:3001/contacts/edit".gsub(/#{site}/, '')
site
site += ':3000'
"http://portal.local:3000/contacts/edit".gsub(/#{site}/, '')
site.gsub!(/:3000$/, '')
site.include?(':')
Contact.orphaned
[:foo].tap { |a| a << :bar if :bar }
[:foo].tap { |a| a << :bar if false }
[:foo].tap { |a| a.shift :bar if true }
[:foo].tap { |a| a.shift(:bar) if true }
[:foo].tap { |a| a.unshift(:bar) if true }
u=User.first
u.project_admin? nil
u1=User.find_by_email("reidmix@gmail.com")
u.project_admin nil
u.admin?
u1.project_admin? nil
  def webphone_url email_or_attuid
    return email_or_attuid if email_or_attuid !~ ATT_UID_REGEX
    "http://webphone.att.com/cgi-bin/webphones.pl?id=#{attuid}"
  end
webphone_url rx278x
webphone_url 'rx278x'
  ATT_UID_REGEX = /^([a-zA-Z]{2}[0-9]{3}[a-zA-Z0-9]{1})(?:@att.com)?/
    "http://webphone.att.com/cgi-bin/webphones.pl?id=#{$1}"
webphone_url 'rx278x@att.com'
webphone_url 'rx278x@att.net'
webphone_url 'rx278x@comcast.com'
  def webphone_url attuid
    return attuid if attuid !~ ATT_UID_REGEX
webphone_url 'rx278f@comcast.com'
  ATT_UID_REGEX = /^([a-zA-Z]{2}[0-9]{3}[a-zA-Z0-9]{1})(?:@att.com)?$/
link_to webphone_url 'rx278x@att.net'
link_to webphone_url('rx278x@att.net')
include UrlHelpers
include ActionView::Helpers::UrlHelpers
include ActionView::Helpers::UrlHelper
include ActionView::Helpers
include ActionDispatch::Routing
include Rails.application.routes.url_helpers
ActionDispatch::Routing
ActionView::Helpers::UrlHelper
link_to 'http://google.com'
default_url_options[:host] = "localhost"
url_for()
class LinkHelper; include ActionView::Helpers; end
helper = LinkHelper.new
helper.link_to 'http://google.com'
helper.mail_to 'http://google.com'
helper.link_to 'rf278x'
helper.link_to 'rf278x@att.com'
helper.link_to 'Google', 'rf278x@att.com'
'foo' =~ ATT_UID_REGEX
'rx278x' =~ ATT_UID_REGEX
'rx278x' =~ ATT_UID_REGEX && 'yes'
'rx278x' =~ ATT_UID_REGEX && 'yes' || 'no'
'rx278' =~ ATT_UID_REGEX && 'yes' || 'no'
{}.reverse_merge(target: 'default')
(h={}).reverse_merge(target: 'default')
h
(h={target: 'foo'}).reverse_merge(target: 'default')
nil =~ ATT_UID_REGEX
Identity.first
Identity.first.user
Identity.find_by_user_id(1)
i=Identity.find_by_user_id(1)
Identity.find_by_openstack_identifier('a7322faf05d44038a4398a060880ab8b')
Contact
SLP.const_get('caportal-prod-a-dfw2', false)
SLP.const_get('Ewr1', false)
+1
z.tenants
z.tenants.first.project
u.serialized_attributes
User.serialized_attributes
me.versions
ls
me
me.role='admin'
me.class.serialized_attributes
me.versions.first
old=me.versions.first.reify
me.changes
me.role='developer'
me.serialized_attributes
me.changed_attributes
me.version.changes
me.version.changeset
me.versions.changeset
me.previous_version.changeset
me.versions.first.changeset
me.reload
me.role = 'developer'
me.role
me.version.first.changeset
me.previous_version
me.versions.last
me.versions.last.reify
me.attributes
me.attributes.grep /pass/
me.attributes.keys.grep /pass/
p=Project.first
p.zone
p.tenant.zone
p.tenants
p.tenants.map(&:zone)
p.tenants.map(&:zone).map(&:name)
Zone
p.tenants.map(&:zone).map(&:code)
p.tenants.distinct.map(&:zone).map(&:code)
p.tenants(distinct: true)
p.tenants.zones(distinct: true)
p
p.zones
p.zones.map(&:code)
p.zones.length
Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1))
Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1)).to_sql
puts Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1)).to_sql
puts Project.where(:project_id => Membership.select(:project_id).where(:user_id => 1))
puts Project.where(:id => Tenant.select(:project_id).join(:credentials).where(:user_id => user)).to_sql
puts Project.where(:id => Tenant.select(:project_id).join(:credentials).where(:user_id => 1)).to_sql
Project.accessible_to(User.first).to_sql
puts Project.accessible_to(User.first).to_sql
puts Project.accessible_to2(User.first).to_sql
puts Project.accessible_to2(1).to_sql
Project.memberships_project_ids_for(1)
Project.memberships_project_ids_for(1).to_sql
puts Project.memberships_project_ids_for(1).to_sql
puts Project.credentials_project_ids_for(1).to_sql
Project.accessible_to2(1).to_sql
Project.memberships_project_ids_for(user).where_values
Project.memberships_project_ids_for(1).where_values
Project.memberships_project_ids_for(1).where_values.to_sql
Project.memberships_project_ids_for(1).where_values.reduce(:and)to_sql
Project.memberships_project_ids_for(1).where_values.reduce(:and)
puts Project.accessible_to(1).to_sql
puts Project.accessible_to(1)
Project.accessible_to(1)
Project.accessible_to(1).map(&:name)
Project.accessible_to(2).map(&:name)
Project.accessible_to(3).map(&:name)
reload!@
EmailValidator
EmailValidator::EmailAddressRegex
include 'benchmark'
require 'benchmark'
Benchmark.bm { 1000.times do { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.bm { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.realtime { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } / 1000
Benchmark.realtime { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } 
Benchmark.bm { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } 
Benchmark.bm { x.report("times:") { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } }
Benchmark.bm { |x| x.report("times:") { 1000.times { 'foo@bar.com' =~ EmailValidator::EmailAddressRegex } } }
Benchmark.realtime { 1000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } / 1000
Benchmark.realtime { 10000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } / 10000
Benchmark.realtime { 100000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 1000000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 750000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 600000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Benchmark.realtime { 700000.times { EmailValidator::EmailAddressRegex =~ 'foo@bar.com' } } 
Project.accessible_to.to_sql
Project.accessible_to(1).to_sql
Project.membership_projects_for(1).union(Project.credential_projects_for(1)).to_sql
reload1
reload
AppConfig
AppConfig.ssh_connections
class Foo; def foo; puts "foo #{wibble}"; end; end
Bar.new.wibble
Foo.new.foo 
class Foo; initialize(bar); @context = bar; end; end
class Foo; def initialize(bar); @context = bar; end; end
f=Foo.new
f=Foo.new(Bar.new)
class Foo; def run method; @context.send method; end; end
f.run(:wibble)
f.foo
class Foo; def foo; puts "foo #{self.wibble}"; end; end
Foo.new.foo
Bar.new.instance_eval { Foo.new.foo } 
undef Foo
class Foo; initialize; end; end
class Foo; initialize; ;  end; end
Foo.new
class Bar; def wibble; 123; end; end
Bar.new.instance_exec { Foo.new.foo }
c=HostImporter::HostConfig
c=HostImporter::HostConfig.new
c.field :test
c.field :test, :test
c.field :test => :test
c.field :test { puts 'yes' }
c.field :test do; puts 'yes'; end
be bundle open activerecord
'server_name'.titleize
[nil].compact.flatten
[:to_i].compact.flatten
[[:to_i, :devide_by_ten]].compact.flatten
'os'.titlelize
'os'.titleize
'o-s'.titleize
'c16r2'.split 'r', 2
  IDENTIFIER_REGEX = /([cso])(\d+)([rp])(\d+)/
'x16r2' =~ IDENTIFIER_REGEX
  IDENTIFIER_REGEX = /([a-z])(\d+)([rp])([a-z])/
  def node
    identifier =~ IDENTIFIER_REGEX
    {
      :type   => $1,
      :number => $2,
      :rack   => {
        :prefix => $3,
        :row    => $4
      }
    }
identifier = 'c16r2'
node[:type]
def identifier
'c16r2'
node[:number]
  IDENTIFIER_REGEX = /([a-z])(\d+)([rp])(\d+)/
 NODE_TYPES = {
    :c => 'compute',
    :s => 'storage',
    :o => 'ops'
  }.with_indifferent_access
  # set a default value & freeze
  NODE_TYPES.default = 'unknown'
  NODE_TYPES.freeze
NODE_TYPES[node[:type]]
def identifier; 'x12r23'; end
node[:rack][:prefix]
node[:rack][:row]
def identifier; 'aaaaaaaa'; end
node
'c12r23'.split 'r', 2
x = 'c12r23'.split 'r', 2
x.first
x.first[1..-1]
''.hostname '.'
''.split '.'
class Foo; attr_accessible :config; end
class Foo; attr_accessor :config; end
Foo.setup
Foo.new.config
class Foo; def config; self.class.config; end; end
Foo.config
Foo.methods - 1.methods
Foo.new.setup
class Foo; def setup; self.class.setup; end; end
class Bar; class_attribute :config; end
class Bar; class << self; def setup; @config = 'yay'; end; end
;end
Bar.setup
Bar.new.config
class Bar; class << self; def setup; config = 'yay'; end; end; end
class A
class_attribute :x
A.x = 'yay'
A.new.x
class Bar; class << self; def setup; self.config = 'yay'; end; end; end
zone = Zone.find_by_code('dfw1')
zone = Zone.find_by_code('dfw2')
zone.server_racks
sr=zone.server_racks.first_or_create! :rack_identifier => 23, :node_type => 'compute'
sr.node_type
quit
class Foo; def import(s); s.tap {|s| before_import(s) }.each {|d| puts d }; end; end;
end;
class Foo; def import(s); s.tap {|s| before_import(s) }.each {|d| puts d }; end; end
class Bar < Foo
before_import {|s| puts s.length; s.reject! {|d| d.include?('x') } }
class Foo
def import s
  s.tap do |s| 
    preprocess && preprocess.call(s)
  end.each do |d|
    puts d
attr_accessor :preprocess
class << self
  def import stream
    stream.tap do |s|
      preprocess && preprocess.call(s)
    end.each do |d|
      puts d
  attr_accessor :preprocess
  def before_import &block
    preprocess = &block
  class << self
    attr_acccessor :callback
    def import stream
      stream.tap do |s|
        callback.call(s) if callback
      end.each do |data|
        puts data
      end
    def before_import &block
      callback = block
  before_import do |s|
    puts "BEFORE: #{s.length}"
    s.reject! { |d| d.include?('x') }
    puts " AFTER: #{s.length}"
    attr_accessor :callback
Bar.new.import %w[a b c d e f]
Bar.import %w[a b c d e f]
Bar.import %w[a b c d e f x]
        puts callback
        puts "CALLBACK? #{callback.inspect}"
      self.callback = block
c=Contacts.first
c=Contact.first
n=Contact.new
n.first_name = 'Reid"
'
n.first_name = 'Reid'
n.last_name = 'MacDonald'
n.email = c.email.upcase
n.valid?
n.errors.messages
{:foo=>'bar}.each_value(&:upcase)
"
{:foo=>'bar'}.each_value(&:upcase)
{:foo=>'bar'}.each_value!(&:upcase)
(h={:foo=>'bar'}).each_value(&:upcase)
(h={:foo=>'bar'}).each_value { |v| puts v.upcase }
(h={:foo=>'bar'}).each_value { |v| v.upcase! }
{:foo=>'bar'}.each_value!(&:upcase!)
{:foo=>'bar'}.each_value(&:upcase!)
i=(h={:foo=>'bar'}).dup.each_value!(&:upcase!)
i=(h={:foo=>'bar'}).dup.each_value(&:upcase!)
i
i=(h={:foo=>'bar'}).clone.each_value(&:upcase!)
i=(h={:foo=>'bar'}).map.each_value(&:upcase!)
Contacts.first
Contact.first
Contact.find_by_email c.email.upcase
Contact.find_by_email c.email
n
n = Contact.new
n.first_name='Reid'
n.last_name='MacDonald'
Contact.find_by_email 'REIDMIX@gmail.com'
class Foo; attr_accessor :host; end
f.host = 'foo'
f.instance_variable_get(:host)
Foo.new do 
f=Foo.new do |foo|
foo.host = 'reid'
f
f.host
Foo.new do |o| 
puts o.inspect
Foo.new { |o| puts 'test' }
class Foo; def bar(s='bar'); yield s; end 
Foo.bar
Foo.new.bar
Foo.new.bar {|s| puts s; 'baz'}
s=Foo.new.bar {|s| puts s; 'baz'}
s
[].push 'a'
{:a => 'b', :c => 'd'}.reverse_merge(:a=>'z')
{:a => 'b', :c => 'd'}.merge(:a=>'z')
{:a => 'z'}.reverse_merge(:a=>'b', :c => 'd')
Module Bax
module Bar
def hostname
  'default
module Bar; def hostname; 'default'; end; end
class Baz
include Bar
def hostname; 'override'; end
Baz.new.hostname
hi=HostImporter.new Zone.first, {:hostname => 'c16r12.attcompute.com'}
hi.hostname
hi.class.configure
hi.class.configure {}
hi.config
hi.config = HostConfig.new
hi
h=Host.new
host.name
hi.config.hostname
hi = HostImporter.new Zonf.first
hi.identifier
hi.valid_identifier
hi.valid_identifier?
hi.node[:id]
hi.node[:type]
hi.node[:rack][:prefix]
hi.node[:rack][:id]
hi.find_host
hi.send(:find_host)
h=hi.send(:find_host)
h.id
h.new_record?
hi.config.finder
zone
hi.zone
hi.send(hi.config.parent)
hi.send(hi.config.parent).send(hi.config.record)
hi.send(hi.config.parent).send(hi.config.record).send(config.finder)
hi.send(hi.config.parent).send(hi.config.record).send(hi.config.finder)
hi.send(hi.config.parent).send(hi.config.record).send(hi.config.finder).where(:identifier => 'c12r13')
zone.hosts.where(:identifier => 'c7r7').find
Zone.first.hosts.where(:identifier => 'c7r7').find
Zone.first.hosts.first_or_create.where(:identifier => 'c7r7')
Zone.first.hosts.first_or_create(:identifier => 'c7r7')
Zone.first.hosts
Zone.first.hosts.send(:find_or_create, :identifier => 'c12r13')
Zone.first.hosts.send(:first_or_create, :identifier => 'c12r13')
Zone.first.hosts.first_or_create(:identifier => 'c12r13')
Zone.first.hosts.where(config.lookup => identifier).first_or_create
Zone.first.hosts.where(hi.config.lookup => identifier).first_or_create
Zone.first.hosts.where(hi.config.lookup => hi.identifier).first_or_create
hi=HostImporter.new(Zone.first, {:hostname => 'c16r12.attcompute.com'})
hi.send :find_host
Zone.first.hosts.where(:identifier => 'c16r12').first
Zone.first.hosts.where(:identifier => 'c16r12').last
Zone.first.hosts.where(:identifier => 'c16r12').find
Zone.first.hosts.where(:identifier => 'c16r12').all
IRB.conf
IRB.conf[:HISTORY_PATH]
